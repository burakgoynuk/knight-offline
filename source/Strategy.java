//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : 443-Hw1
//  @ File Name : Strategy.java
//  @ Date : 08.04.2015
//  @ Author : Burak Goynuk
//
//
//package pkg443.hw1;



public abstract class Strategy {
	public Knight targetToAttack = null;
	public abstract void step(Knight knight, double deltaTime);
	public Strategy act(Knight knight) {
            return null;
	
	}
        
        
        static double findDistanceCoor( double x1, double y1, double x2, double y2 ){
            double xDiff = x1 - x2;
            double yDiff = y1 - y2;
            
            return Math.sqrt( xDiff*xDiff + yDiff*yDiff );

        }
        
        static double findDistance(Knight k1, Knight k2){
           double xDiff = k1.xPos - k2.xPos;
           double yDiff = k1.yPos - k2.yPos;
           
           return Math.sqrt( xDiff*xDiff + yDiff*yDiff );
        
        }
        
        static boolean atTargetX( double sourceX, double destX ){
            
            if ( destX - sourceX <= 0.0001 )
                return true;
            return false;
        
        }
        
        
        static boolean atTarget( double sourceX, double sourceY, double targetX, double targetY ){
            boolean at = false;
            double distance = findDistanceCoor( sourceX, sourceY, targetX, targetY );
            
            if ( distance <= 0.00001 )
            {
                return true;
            }    
        
            return false;
        }
        
        
        static int moveKnight(Knight k1, double destX, double destY, double deltaTime){
            
            double deltaX = destX - k1.xPos ;
            double deltaY = destY - k1.yPos ;

            double distance = Math.sqrt( deltaX*deltaX + deltaY*deltaY ) ;

            if ( distance == 0.0 )
            {
                return 0;
            }

            double stepX = (deltaX / distance) * k1.speed * deltaTime ;
            double stepY = (deltaY / distance) * k1.speed * deltaTime ;

            if ( distance < k1.speed )
            {
              stepX = deltaX ;
              stepY = deltaY ;
            }

            k1.xPos += stepX ;
            k1.yPos += stepY ;
            
            return 1;
            
        }

}
        
